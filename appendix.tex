\appendix
\appendixpage

\chapter{Дополнительная информация по работе с~Simics} \label{chap:append01}

В данное приложение включены сведения о различных приёмах, используемых при ежедневном использовании Simics, не описанные в главах, посвящённых индивидуальным лабораторным работам.

\section{Обновление workspace}

Для получения последних исправлений ошибок в моделях необходимо использовать самую свежую версию базового пакета Simics из  установленных на кластере. Номер версии определить по файлам, установленным в папке \texttt{/share/simics/simics-4.6/}. В тексте данной работы последней версией будет считаться \textbf{4.6.32}, при этом 4.6 --- это основная версия, а последняя цифра --- номер минорной версии обновления. Он будет использован позже.

Каждая копия workspace характеризуется версиями пакетов, в ней используемых. Номер пакета Simics Base определяет настройки версий остальных пакетов, установленных одновременно с ним. Для того чтобы увидеть список пакетов с их версиями, используйте команду:

\begin{lstlisting}
$ ./simics -v
Simics Base                                        1000    4.6.32    (4051)
Model Library: Intel Core i7 with X58 and ICH10    2075    4.6.21    (4051)
Model Builder                                      1010    4.6.14    (4051)
Extension Builder                                  1012    4.6.6     (4042)
\end{lstlisting}

В примере сверху базовый пакет имеет версию 4.6.32. Новые пакеты будут периодически ставиться на кластере для исправления ошибок в базовых моделях. Для обновления своего workspace используйте команду \texttt{workspace-setup}, находящуюся внутри новой версии базового пакета (версии 4.6.\textbf{<minor>}), выполненную внутри workspace, который вы хотите обновить.

\begin{lstlisting}
$ /share/simics/simics-4.6/simics-4.6.<minor>/bin/workspace-setup
\end{lstlisting}

Также версию Simics можно узнать прямо изнутри симуляции:

\begin{lstlisting}
simics> version
\end{lstlisting}

\section{Список часто используемых команд Simics}

\begin{center}
\begin{tabularx}{\textwidth}{|X|X|p{0.4\textwidth}|}\hline
%\begin{longtable}{|p{0.3\textwidth}|l|p{0.3\textwidth}|}\hline
\textbf{Команда}                          & \textbf{Синонимы}  & \textbf{Выполняемая функция}\\\hline
\texttt{continue}                         & \texttt{c, r, run} & Начать или продолжить симуляцию\\\hline
\texttt{stop}     						  &                    & Остановить симуляцию\\\hline
\texttt{step-cycle [count]}				  & \texttt{sc}		   & Исполнить count циклов, печатаю следующую инструкцию\\\hline
\texttt{exit}     						  & \texttt{quit, q}   & Выйти из симулятора\\\hline
\texttt{run-command-file <script.simics>} &                    & Выполнить скрипт Simics\\\hline
\texttt{pregs [-all]}                     &                    & Распечатать содержимое регистров текущего процессора\\\hline
\texttt{print-time [-all]}                & \texttt{ptime}     & Вывести значение виртуального времени процессора\\\hline
\texttt{help <command>}                   & \texttt{h, man}    & Вывести справку о команде или понятии \\\hline
\texttt{win-help}                         &                    & Открыть окно индексируемой справки \\\hline
\texttt{win-control}                      &                    & Открыть окно \textbf{Simics Control}\\\hline
\texttt{\%<register name>}                & \texttt{read-reg, write-reg} & Прочитать или записать содержимое регистра текущего процессора \\\hline
\texttt{output-radix <10|16>}             &                    & Изменить основание используемой для вывода чисел системы счисления\\\hline
\texttt{delete [id]}                      &                    & Удалить точку останова по её номеру \\\hline
\end{tabularx}

% \end{longtable}
\end{center}

\chapter{Скрипт для отладки}\label{chap:app-broken-script}

\begin{lstlisting}
name_prefix = cli.simenv.host_name
if name_prefix != "":
    name_prefix = name_prefix + "_"

sample_risc0 = pre_conf_object(name_prefix + "sample_risc0", "sample-risc")
sample_risc0.queue = sample_risc0

ram_image0 = pre_conf_object(name_prefix + "ram_image0", "image")
ram_image0.queue = sample_risc0
ram_image0.size = 0x800000

ram0 = pre_conf_object(name_prefix + "ram0", "ram")
ram0.image = ram_image0

phys_mem0 = pre_conf_object(name_prefix + "phys_mem0", "memory-space")
phys_mem0.queue = sample_risc0
phys_mem0.map = [[     0x0, ram0,                 0, 0, 0x800000],
                ]

ctx0 = pre_conf_object(name_prefix + "ctx0", "context")
ctx0.queue = sample_risc0

sample_core0 = pre_conf_object(name_prefix + "sample_core0", "sample-risc-core")
sample_core0.queue = sample_risc0
sample_core0.sample_risc = sample_risc0
sample_core0.physical_memory_space = phys_mem0
sample_core0.current_context = ctx0

#cosim_cell = pre_conf_object(name_prefix + "cosim_cell", "cell")
#cosim_cell.current_processor = sample_core0
#cosim_cell.current_step_obj = sample_risc0
#cosim_cell.current_cycle_obj = sample_risc0
#cosim_cell.scheduled_object = sample_risc0
#sample_risc0.cell = cosim_cell

SIM_add_configuration([sample_risc0, ctx0, ram_image0, ram0, phys_mem0, sample_core0, sample_core1], None)
\end{lstlisting}

\chapter{Код целевого скрипта practicum.simics}\label{chap:target-script}

\begin{lstlisting}
# Script for mipt practicum
load-module pci-components
load-module std-components
load-module x86-comp
load-module x86-nehalem-comp
load-module x58-ich10-comp
load-module memory-comp

add-directory "%simics%/targets/x86-x58-ich10/images/"

$disk_image         = "/share_debian/hpc-images/debian-master-2012-05-12.craff"
$cpu_class          = core-i7-single
$freq_mhz           = 3300
$cpi                = 1
$disk_size          = 20496236544
$rtc_time           = "2008-06-05 23:52:01 UTC"
$memory_megs        = 2048
$text_console       = TURE
$use_acpi           = TRUE
$gpu                = "accel-vga"
$bios               = "seabios-simics-x58-ich10-0.6.0-20110324.bin"
$break_on_reboot    = TRUE
$apic_freq_mhz      = 133
$use_vmp            = TRUE
$spi_flash          = "spi-flash.bin"
$mac_address        = "00:19:A0:E1:1C:9F"
$host_name          = "practicum"

$system = (create-x86-chassis name = $host_name)

### motherboard
$motherboard = (create-motherboard-x58-ich10 $system.mb
        rtc_time = $rtc_time
        acpi = $use_acpi
        break_on_reboot = $break_on_reboot
        bios = $bios
	    mac_address = $mac_address
        spi_flash = $spi_flash)
$southbridge = $motherboard.sb
$northbridge = $motherboard.nb

### processor
$create_processor = "create-processor-" + $cpu_class
$create_processor_command = (
        $create_processor
        + " $motherboard.cpu0"
        + " freq_mhz = $freq_mhz"
        + " apic_freq_mhz = $apic_freq_mhz"
        + " use_vmp = $use_vmp"
        + " cpi = $cpi")
$cpu0 = (exec $create_processor_command)
connect $motherboard.socket[0] $cpu0.socket

### memory
$dimm = (create-simple-memory-module $motherboard.memory
                                      memory_megs = $memory_megs)
connect $motherboard.dimm[0] $dimm.mem_bus

### GPU
$vga = (create-pci-accel-vga $motherboard.gpu)
connect $northbridge.gpu $vga.connector_pci_bus

### consoles
$console = (create-std-text-graphics-console $system.console)
$console.connect keyboard $southbridge
$console.connect $vga

### disk
if not (lookup-file $disk_image) {
    interrupt-script "Disk image file not found: " + $disk_image
}
$disk = (create-std-ide-disk $system.disk size = $disk_size file = $disk_image)
$southbridge.connect "ide_slot[0]" $disk

instantiate-components

#SimicsFS support (add SimicsFS pseudo device)
$hostfs = python "SIM_create_object('hostfs', 'hfs0', [])"
practicum.mb.phys_mem.add-map $hostfs 0xfed2_0000 16

try {
    win-command-line
} except { echo "Failed to create GUI"}

script-branch { # Automatize GRUB and login
    local $con = $host_name.console.con
    $con.wait-for-string "automatically in 5s"
    $con.input "\n"
    $con.wait-for-string "login:"
    $con.input "user\n"
    $con.wait-for-string "Password:"
    $con.input "user\n"
}

\end{lstlisting}

\chapter{Программа debug_example.c}\label{chap:debug-example}

\begin{lstlisting}
/*
 * This program  reads input and converts it to uppercase.
 * It has an intentional bug included that makes it crash on certain inputs.
 * 
 * Usage: stdin - input string.
 * Compile with gcc -static -g debug_example.c -o debug_example
 */
	
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

void read_input(char* in) {
    char symbol;
    in[0] = 0; // initialize the string with zero length
    while((symbol = getchar()) != EOF) {
        *in++ = symbol;
    }
    *in = 0; // close the string
}

void convert_to_uppercase(char * in, char *out) {
    int i;
    for (i =0; i <= strlen(in); i++) {
        if (isalpha(in[i]))
            out[i] = toupper(in[i]);
        else
            out[i] = in[i];
    }
}

int main(int argc, char** argv) {
    char input[32], *output;
    
    read_input(input);
    convert_to_uppercase(input, output);
    
    printf("%s\n", output);
    return 0;
}
\end{lstlisting}