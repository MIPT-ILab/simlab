\chapter{Создание программных моделей}\label{chap:lab-model-builder}

\section{Цель занятия}

В данной лабораторной работе продолжается изучение принципов работы симулятора Simics. В ней будут определены основные понятия, используемые при работе с симуляцией и при написании моделей устройств.

\section{Сборка моделей устройств}

\subsection{Генерация шаблонного устройства}

\subsection{Сборка с помощью Make}



\section{Атрибуты}

\section{Интерфейсы}

Каждый интерфейс имеет уникальное имя и фиксированный набор методов, объединённых общей целью. Модель, желающая предоставлять некоторый интерфейс для других устройств, обязана реализовать один или несколько его методов и затем объявить его доступным. Стороннее устройство, имеющее ссылку на объект, может получить по нему заявленные интерфейсы и вызывать включённые в него методы. Таким образом, в Simics интерфейсы предоставляют объектно-ориентированную парадигму для взаимодействия отдельных моделей. 

Например, один из атрибутов процессора, настраиваемый на этапе инициализации модели, --- это \texttt{physical_memory}, его тип \texttt{o}, т.е. <<объект>>. Допустим, что \texttt{cpu->physical_memory = mem}. По указателю на объект \texttt{mem} процессор может извлечь из него реализацию интерфейса \texttt{memory-space}, который содержит методы \texttt{read}, \texttt{write}, \texttt{access} и др. для работы с пространствами памяти.

В данной работе мы не будем уделять много внимания  деталям работы с интерфейсами. Отметим лишь, что все команды любого устройства внутри себя написаны с использованием только его атрибутов и интерфейсов, т.к. не существует другого способа взаимодействий с ним. Однако устройства должны взаимодействовать друг с другом только через интерфейсы, но не атрибуты.

\section{Модули устройств}

С точки зрения организации хранения в Simics любая модель предоставляется ровно одним \textit{модулем} --- разделяемой библиотекой, загружаемой на этапе инициализации или позже. При этом модуль может предоставлять более одного класса моделей.

Для просмотра текущих загруженных модулей используйте команду:

\begin{lstlisting}
simics> list-modules -l
\end{lstlisting}

Для загрузки некоторого модуля вручную используется команда \texttt{load-module}.

Кроме того, некоторые найденные модули по той или иной причине могут быть отвергнуты при загрузке. Увидеть их список можно с помощью команды \texttt{list-failed-modules}.

% \subsection{Псевдоустройства}
% 
% Для унификации работы с различными сущностями в активной сессии Simics присутствуют также псевдоустройства, такие как \texttt{sim}, \texttt{prefs}, \texttt{sysmon} и др.

\section{Последовательность создания модели системы}

При создании симуляции она и все участвующие в ней объекты проходят две фазы, чётко отделённые друг от друга во времени, тогда как внутри каждой из них порядок инициализации компонент неопределён.

\begin{enumerate*}

\item \textit{Объявление} устройств и соединение их с помощью инициализации их атрибутов. На этом этапе ещё не произодится проверок на соответствие типов, наличие всех обязательных атрибутов. Устройства представлены так называемыми предобъектами (\abbr preobj).

\item \textit{Инстанциирование} устройств с помощью команды \texttt{instantiate-components}. На этом этапе производятся все проверки на корректность атрибутов, наличие необходимых интерфейсов. Если не найдено ошибок, то предобъекты преобразуются в полноценные объекты Simics, которые могут участввать в симуляции.

\end{enumerate*}

Отметим, что при необходимости добавить новые объекты в процессе симуляции описанные фазы могут быть повторены.

\section{Тестирование моделей}

Подробнее о написании юнит-тестов для моделей Simics говорится в~\cite{writing-tests}.

\section{Ход работы}

% \section{}

\section{Контрольные вопросы}

\begin{enumerate*}
\item 
\item 
\item 
\end{enumerate*}

\iftoggle{webpaper}{
    \printbibliography[title={Список литературы к занятию}]
}{}

