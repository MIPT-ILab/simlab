\chapter{Создание программных моделей}\label{chap:lab-model-builder}

\section{Цель занятия}

В данной лабораторной работе продолжается изучение принципов работы симулятора Simics. В ней будут определены основные понятия, используемые при работе с симуляцией и при написании моделей устройств. В качестве основного языка программирования моделей будет использоваться Си.

Кроме использования готовых моделей устройств из поставляемых в составе Simics, имеется возможность создавать свои собственные модели различных устройств. Для этого симулятор предоставляет среду сборки, API для взаимодействия с симулятором и специальный язык DML для быстрой разработки периферийных устройств\footnote{В данной работе DML не будет использоваться; однако Simics API доступен из всех поддерживаемых языков, включая Python, Си и C++.}. Подробное описание принципов написания моделей периферийных устройств дано в~\cite{model-builder}; особенности интеграции моделей центральных процессоров описываются в~\cite{processor-integration}.

\section{Модули Simics}
Базовая единица загрузки нового кода Simics --- \textit{модуль}, разделяемая библиотека (в Linux это файлы с расширением .so или .pymod), использующая API Simics. Каждый класс объектов должен содержаться максимум в одном модуле. При этом один модуль может содержать в себе более одного класса моделей.

Для просмотра текущих загруженных в симуляцию модулей используйте команду \texttt{list-modules -l}. Например, в <<пустой>> симуляции этот список выглядит так (флаг \texttt{-v} позволяет увидеть больше информации о том, откуда загружены модули):

\begin{lstlisting}
simics> list-modules -v -l
Name                    Status   ABI  Build ID  Thread-safe
Path
-----------------------------------------------------------
breakpoint-manager      Loaded  4052      4145  Yes
/opt/simics/simics-4.6/simics-4.6.103/linux64/lib/breakpoint-manager.so
software-tracker        Loaded  4052      4145  Yes
/opt/simics/simics-4.6/simics-4.6.103/linux64/lib/software-tracker.pymod
software-tracker-iface  Loaded  4052      4145  Yes
/opt/simics/simics-4.6/simics-4.6.103/linux64/lib/software-tracker-iface.so
\end{lstlisting}

Поиск стандартных модулей, доступных для загрузки, проводится при старте Simics в директориях инсталляции базового и других пакетов. Пользовательские пакеты ищутся в текущем workspace в подпапке \texttt{linux64/lib}. Они помещаются туда в результате успешной компиляции из исходных кодов.

Для загрузки некоторого модуля из командной строки вручную используется команда \texttt{load-module <name>}. После этого становятся доступны все классы и команды, определённые в нём, т.е. можно создавать новые объекты для моделей устройств новых классов.

\section[Исходный код и сборка]{Исходный код и сборка моделей устройств}

Код всех модулей дожен быть размещён в текущем workspace, в поддиректории \texttt{modules}. По общим соглашениям имя директории должно совпадать с именем модуля.
Система сбоки модулей Simics довольно сложна и требует строгого соблюдения процедуры. Она основана на GNU Make~\cite{gmake} и использует компилятор GCC на всех поддерживаемых хозяйских платформах.

\subsection{Генерация шаблонного устройства}

Для начала необходимо сгенерировать <<скелет>> нового устройства --- минимально необходимый набор файлов. Это позволит начать работать с уже компилирующимся примером.

Из workspace выполните команду:

\begin{lstlisting}
$ ./bin/workspace-setup --copy-device sample-device-c
\end{lstlisting}

Теперь в директории \texttt{modules} появился новый элемент \texttt{sample-device-c} с исходными файлами:
\begin{lstlisting}
$ ls -R modules/
modules/:
sample-device-c

modules/sample-device-c:
Makefile  commands.py  sample-device.c  test

modules/sample-device-c/test:
SUITEINFO  s-sample-c.py
\end{lstlisting}

\subsection{Сборка с помощью Make}

Для запуска сборки достаточно использовать программу \texttt{make} с именем цели, совпадающей с именем модуля:
\begin{lstlisting}
make sample-device-c
=== Environment Check ===
'/home/simics/workspace' is up-to date
gcc version 4.6.2
=== Building module "sample-device-c" ===
        module_id.c
DEP     module_id.d
DEP     sample-device.d
CC      sample-device.o
CC      module_id.o
CCLD    sample-device-c.so
        mod_sample_device_c_commands.pyc
\end{lstlisting}

\section{Атрибуты}

\todo

\section{Интерфейсы}

Каждый интерфейс имеет уникальное имя и фиксированный набор методов, объединённых общей целью. Модель, желающая предоставлять некоторый интерфейс для других устройств, обязана реализовать один или несколько его методов и затем объявить его доступным. Стороннее устройство, имеющее ссылку на объект, может получить по нему заявленные интерфейсы и вызывать включённые в него методы. Таким образом, в Simics интерфейсы предоставляют объектно-ориентированную парадигму для взаимодействия отдельных моделей. 

Например, один из атрибутов процессора, настраиваемый на этапе инициализации модели, --- это \texttt{physical_memory}, его тип \texttt{o}, т.е. <<объект>>. Допустим, что \texttt{cpu->physical_memory = mem}. По указателю на объект \texttt{mem} процессор может извлечь из него реализацию интерфейса \texttt{memory-space}, который содержит методы \texttt{read}, \texttt{write}, \texttt{access} и др. для работы с пространствами памяти.

В данной работе мы не будем уделять много внимания  деталям работы с интерфейсами. Отметим лишь, что все команды любого устройства внутри себя написаны с использованием только его атрибутов и интерфейсов, т.к. не существует другого способа взаимодействий с ним. Однако устройства должны взаимодействовать друг с другом только через интерфейсы, но не атрибуты.


\section{Ход работы}

\todo
% \section{}

\section{Контрольные вопросы}

\begin{enumerate*}
\item Чем отличается вывод команды \texttt{list-modules} с флагом \texttt{-l} и без него?
\item Некоторые найденные модули по той или иной причине могут быть отвергнуты при загрузке. Увидеть их список можно с помощью команды \texttt{list-failed-modules}. Загрузите модель Viper и определите причины, по которым список, выдаваемый командой \texttt{list-failed-modules}, не пуст.

\item По каким причинам не следует использовать манипуляцию атрибутами одного устройства из другого?
\end{enumerate*}

\iftoggle{webpaper}{
    \printbibliography[title={Список литературы к занятию}]
}{}

