\chapter{Моделирование платформы с архитектурой CHIP16}\label{chap:lab05}

Данная практическая работа посвящена реализации модели компьютерной платформы, основанной на спецификации CHIP16~\cite{chip16-ngemu} --- полностью виртуальной системы, предназначенной для запуска простых видеоигр и демо. Модель строится на основе API Simics и оформляется как набор модулей и сценариев для данного симулятора.

\section{Исходные спецификации CHIP16}

CHIP16 --- это компьютер с RISC-подобным процессором архитектуры фон-Неймана, работающий на частоте 1~МГц, имеющий 64~кбайт ОЗУ, со спрайтовой 16-цветной графикой разрешением 320×240, двумя джойстиками с 8 кнопками каждый и одноканальной звуковой картой. Доступы в память осуществляются в порядке Little-endian. Регистры устройств и системные шины имеют ширину до 16~бит, однако ширина машинных инструкций — 32~бита.

\subsection{Существующие приложения}

\begin{itemize}
    \item Референсный симулятор --- \textsc{mash16}~\cite{chip16-mach16}.
    \item Описание устройств, набора инструкций и периферии~\cite{chip16-machspec}.
    \item Готовые образы памяти с приложениями~\cite{chip16-roms}.
\end{itemize}

\section{Структурная схема платформы}

Базовые узлы системы показаны на рис.~\ref{fig:chip16-platform}. Каждый блок представляет собой один класс Simics, имя которого стоит после двоеточия. Линиями обозначены соединения устройств, стрелками — направления передачи данных между ними.

\begin{figure}[htbp]
\centering
\begin{tikzpicture}[>=latex, node distance=0.5cm, font=\small]
\begin{scope}[minimum width=4cm]
    \node[draw] (cpu) {\textsc{cpu}: chip16};
    \node[draw, below = of cpu.south west, anchor=north west] (graph) {\textsc{graphics}: graph16};
    \node[draw, below = of graph.south west, anchor=north west] (joystick) {\textsc{joystick}: joy16};
    \node[draw, below = of joystick.south west, anchor=north west] (sound) {\textsc{sound}: snd16};
    \node[draw, above = of cpu.north west, anchor = south west] (timer) {\textsc{timer}: videotimer};
\end{scope}

\begin{scope}[minimum width = 3.9cm, inner xsep = 0pt]
     \node[draw, rotate=90, right = 1cm of sound.south east, anchor=north west] (memory-space) {\textsc{cspace}: memory-space};
    \node[draw, rotate=90, right = 1cm of memory-space.south, anchor = north] (ram) {\textsc{ram}: ram};
    
    \node[draw, rotate=90, left = 1cm of cpu.north west, anchor=south east] (video-space) {\textsc{vspace}: memory-space};
    \node[draw, rotate=90, left = 1cm of video-space.south, anchor = south] (video-ram) {\textsc{video-ram}: ram};
\end{scope}

\draw[<->] (cpu.east) -- (cpu.east -| memory-space.north);
\draw[<->] (graph.east) -- (graph.east -| memory-space.north);
\draw[<-] (sound.east) -- (sound.east -| memory-space.north);
\draw[->] (joystick.east) -- (joystick.east -| memory-space.north);
\draw[<->] (graph.west) -- (graph.west -| video-space.south);

\draw[<->] (memory-space) -- (ram);
\draw[<->] (video-space) -- (video-ram);

\draw[->] (timer.west) -- ([xshift=-0.25cm]timer.west) |- (cpu);
\draw[->] (timer.west) -- ([xshift=-0.25cm]timer.west) |- (graph.175);
\draw[->] (timer.west) -- ([xshift=-0.25cm]timer.west) |- (joystick) node[pos=0.1, rotate=90, above] {\tiny{\scshape \#vblank}};

\end{tikzpicture}
\caption{Схема соединения блоков}\label{fig:chip16-platform}
\end{figure}

\section{Модификации спецификации для полноплатформенной модели}

Оригинальная документация не описывает некоторые важные для практического построения детали взаимодействия узлов. Поэтому для нужд задания вводятся уточнения по принципам работы ряда узлов.

\paragraph{Таймер.} Поскольку многие действия в платформе завязаны на синхросигнал от видеокарты, было добавлено отдельное устройство --- таймер \texttt{timer:videotimer}, генерирующий прерывание \textsc{\#vblank} с периодом 16.67 мс. Он подключен к процессору, видеокарте и джойстикам, которые реагируют на поступление сигнала согласно спецификации.

\paragraph{VBLANK.} Инструкция \textsc{vblank} введена для синхронизации работы ЦПУ с выводом видеокадра. В оригинальной спецификации для этого используется непрерывный опрос процессором сигнала на выходе таймера. В данной работе семантика паузы сохранена, но её реализация изменена. Инструкция \textsc{vblank} вызывает \textit{остановку процессора} до поступления следующего прерывания \textsc{\#vblank}. Процессор реагирует на прерывание пробуждением из режима остановки, если он в нём находится; если он уже работает, то оно игнорируется.

\paragraph{Ввод-вывод через память (MMIO).} Инструкции процессора DRW, PAL, SNG, CLS, BGC, SPR, FLIP, SNDx, SNP предназначены для работы с периферией (видео и звуком). Для их реализации необходимо иметь двунаправленный канал для передачи и приёма сообщений. Для этих нужд используется часть резервированного диапазона адресов I/O. Карта памяти ЦПУ выглядит следующим образом~(табл.~\ref{tab:memmap}). От оригинальной она отличается введением дополнительных регистров в области MMIO.

\begin{table}[htb]
\begin{tabular}{lll}
Диапазон адресов         & Длина & Назначение \\
\texttt{0x0000 -- 0xfdef}& 65008 & ОЗУ        \\
\texttt{0xfdf0 -- 0xffef}& 512   & Стек       \\
\texttt{0xfff0 -- 0xfff1}& 2     & Джойстик 1 \\
\texttt{0xfff2 -- 0xfff3}& 2     & Джойстик 2 \\
\texttt{0xfff4 -- 0xfff5}& 2     & Звуковая карта \\
\texttt{0xfff6 -- 0xfff7}& 2     & Видеокарта \\
\texttt{0xfff8 -- 0xffff}& 8     & Зарезервировано \\
\end{tabular}
\caption{Уточнённая карта памяти CHIP16}
\label{tab:memmap}
\end{table} 

В работе используется уточнённый протокол работы с периферией, который учитывает ограниченность пропускной способности шин в реальных системах. Для передачи команд видеокарте и звуковой карте используются два канала связи по адресам 0xfff6 и 0xfff4 соответственно. Процессор кодирует необходимую для исполнения команду периферийного устройства согласно следующего протокола.

Все команды управления периферией состоят из одного или более 16-битных слов. Первое управляющее слово определяет код команды (8~бит) и длину последовательности (8~бит). На рис.~\ref{fig:periph-command} Opcode --- код операции, Length --- полная длина последующей команды в словах. Последующие слова несут информацию, специфичную для конкретной команды.

\begin{figure}[htb]
    \centering
\bytefieldsetup{bitwidth=0.2cm, endianness = big}
\begin{bytefield}[]{16}
    \bitheader{16, 8, 7, 0} \\
    \bitbox{8}{Opcode} & \bitbox{8}{Length} \\
\end{bytefield}
    \caption{Формат управляющего слова команд периферйных устройств}
    \label{fig:periph-command}
\end{figure}

Устройство, получающее слова текущей команды, сохраняет их в своём внутреннем состоянии до тех пор, пока команда не будет передана полностью. Затем оно исполняет её, используя параметры, сохранённые при передаче. После этого оно начинает ожидать следующую команду.

В первом приближении весь протокол общения между ЦПУ и периферийными устройствами происходит атомарно, т.е. в течение одной машинной инструкции. В последующих улучшенных вариантах модели допускается разнести моменты передачи слов в виртуальном времени.

\paragraph{Видеокарта.} Список команд для видеокарты почти полностью соотвествует аналогичным инструкциям процессора (табл.~\ref{tab:video-commands}).

\begin{table}[htb]
\begin{center}
\begin{tabular}{lll}
\textbf{Упр. слово} & \textbf{Аргументы}   &  \textbf{Описание} \\
0, 3                & RXRX RYRY HHLL       &  Инструкция DRW\\
1, 24               & RRGG BBRR GGBB \dots &  Инструкция PAL \\
2, 1                & N000                 &  Инструкция BGC \\
3, 1                & HHLL                 &  Инструкция SPR \\
4, 1                & V000                 &  Инструкции FLIP \\
\end{tabular}
\end{center}
\caption{Команды видеокарты}
\label{tab:video-commands}
\end{table}

Отметим следующие важные аспекты реализации видеокарты.
\begin{enumerate}
    \item Для работы инструкции DRW видеокарте требуется прямой доступ к ОЗУ для чтения данных спрайта.
    \item Установка флага C (carry) в процессоре после работы инструкции DRW. Значение, читаемое из регистра-канала видеокарты (адрес 0xfff6) содержит статус завершения последней выполненной операции. Для команды (0, 3) возвращается значение 0x0001, если обнаружена коллизия, и 0x0000, если нет.
\end{enumerate}

\paragraph{Звуковая карта.} Имеет меньше управляющих команд (табл.~\ref{tab:sound-commands}), также передаваемых через собственный регистр MMIO по адресу 0xfff4.

\begin{table}[htb]
\begin{center}
\begin{tabular}{lll}
\textbf{Упр. слово} & \textbf{Аргументы}  &  \textbf{Описание} \\
0, 2                &  TONE HHLL &  Инстр. SND0\dots{}SND3, SNP \\
1, 2                &  ADVT SR00 &  Инструкция SNG \\
\end{tabular}
\end{center}
\caption{Команды звуковой карты}
\label{tab:sound-commands}
\end{table}

\section{Ход работы}

В данной секции разобраны общие вопросы организации разработки.
\subsection{Технология разработки}

\begin{itemize}
\item Хранение кода --- в Git \url{https://github.com/yulyugin/ilab-simics}. Лицензия кода --- закрытая, согласно договора предоставления Intel Academic SLA 1.0 (см.~пункт 6.2 соглашения).

\item Документация --- в вики \url{https://github.com/yulyugin/ilab-simics/wiki}.

\item Распределение задач --- по одному модулю Simics на одного--двух выполняющих.
\item Промежуточная проверка качества --- юнит тесты для отдельных устройств.
\item Финальный продукт работы --- набор моделей и связывающий их скрипт (построенный на основе стандартной цели \texttt{cosim}).
\end{itemize}

\subsection{ЦПУ}

Основа для модели --- \texttt{sample-risc}, модифицированный для нужд учебного проекта:
\begin{itemize}
    \item убрана многоядерность;
    \item декодер упрощён до одной инструкции;
	\item код регистрации класса обновлён до современной схемы.
	\item Endianness изменена с BE на LE.
\end{itemize}


\subsection{Видеокарта}

Основа для модели --- \texttt{sample-device-c}. Отрисовка изображения производится через SDL~\cite{sdl2-wiki}.

Пример на русском языке: \url{http://habrahabr.ru/post/134936/}.

\paragraph{Идеи по развитию модели}
\begin{enumerate}
\item Для тестирования необходимо реализовать интерфейс для сохранения скриншота экрана в указанный файл.
\end{enumerate}

\subsection{Джойстик}

Основа для модели --- \texttt{sample-device-c}. Ввод с хозяйской клавиатуры производится через SDL. Для получения фокуса ввода используется отдельное графическое окно.

\todo Описать работу двух джойстиков.

\paragraph{Идеи по развитию модели}
\begin{enumerate}
\item Для тестирования необходимо реализовать интерфейс для инжектирования событий через SDL_PushEvent().                                                                                                   \end{enumerate}


\subsection{Таймер}

Основа для модели --- \texttt{sample-timer-device}. Код пишется на DML.

Для отладки необходимо поддержать возможность выключения генерации прерываний.

\subsection{Звуковая карта}

Основа для модели --- \texttt{sample-device-c}. Вывод звука производится через SDL. Для генерации непрерывных тонов используются события в виртуальном времени «начать генерацию» и «закончить генерацию». Для учёта параметров формы огибающей ADSR сигнал разбивается на макрофазы, каждая из которых моделируется отдельно.

\todo Корректная отработка паузы в симуляции при включенном звуке.

\paragraph{Идеи по развитию модели}
\begin{enumerate}
\item Реализовать альтернативную реализацию, записывающую звук в указанный файл.                                                                          \end{enumerate}


\section{Минимум и максимум цели проекта}

В зависимости от полноты выполнения студентами подзадач проекта выделяются следующие вехи, обозначающие достижение следующей ступени к симуляции, по сравнению с референсной моделью \textsc{mash16}.

\begin{enumerate}
    \item Модель способна исполнять образ памяти, написанный участниками проекта.
    \item Модель способна исполнять образ памяти из директории Demo (графическое приложение без звука и ввода).
    \item Модель способна исполнять образ памяти из директории Demo (графическое приложение со звуком и без ввода).
    \item Модель способна исполнять образ памяти из директории Games (графическое приложение со звуком и вводом с джойстика).
\end{enumerate}

\section{Порядок занятий и заданий}

\begin{tabular}{p{0.4\textwidth}p{0.4\textwidth}}
\textbf{Занятие} & \textbf{Задание} \\\hline
Системы контроля версий Git & Установить Linux, скачать репозиторий проекта, изменить файл, зафиксировать изменения в репозитории \\
Сборка проекта: модули, модели, workspace & Собрать заглушки модулей, создать недостающие устройства (распределение устройств по владельцам) \\
Структура кода моделей Simics: атрибуты, интерфейсы, функция init_local() & Начать заполнять устройства архитектурным состоянием \\
Архитектура CHIP16 & Продолжать работу над устройствами \\
Моделирование ЦПУ через интерпретацию; моделирование графики & Реализовать первые инструкции в процессоре; подключить библиотеку SDL к сборке проекта\\
Моделирование ввода с клавиатуры. Интерактивность симуляции. MMIO. Прерывания & Продолжать писать модели устройств \\
Тестирование устройств. Среда Simics для конфигурации соединения устройств симуляции. & Запустить скрипт targets/chip16; написать свои скрипты для отдельных устройств \\

\end{tabular}

\section{Контрольные вопросы}

\begin{enumerate*}
\item Какие устройства в CHIP16 моделируются как исполняющие, а какие --- как неисполняющие? Почему? Есть ли устройства, которые моделируются как-то по-другому? Почему они не принадлежат ни к одному из двух классов?
\item Почему в данной главе описываются расширения оригинальной спецификации в виде протоколов связи между устройствами, а также дополнительных устройств типа таймера, если в исходной спецификации их нет?
\item Какие проблемы могут возникнуть при симуляции звука, генерируемого звуковой картой, при проигрывании его через физические динамики хозяина?
\end{enumerate*}


\iftoggle{webpaper}{
    \printbibliography[title={Список литературы к занятию}]
}{}