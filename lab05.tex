\chapter{Моделирование платформы с архитектурой CHIP16}\label{chap:lab05}

Данная практическая работа посвящена реализации модели компьютерной платформы, основанной на спецификации CHIP16~\cite{chip16-ngemu} --- полностью виртуальной системы, предназначенной для запуска простых видеоигр и демо. Модель строится на основе API Simics и оформляется как набор модулей и сценариев для данного симулятора.

\section{Исходные спецификации CHIP16}

CHIP16 --- это компьютер с RISC-подобным процессором архитектуры фон-Неймана, работающий на частоте 1~МГц, имеющий 64 кбайт ОЗУ, со спрайтовой 16-цветной графикой разрешением 320×240, двумя джойстиками с 8 кнопками каждый и одноканальной звуковой картой. Доступы в память осуществляются в порядке Little-endian.

\subsection{Существующие приложения}

\begin{itemize}
    \item Референсный симулятор --- \textsc{mash16}~\cite{chip16-mach16}.
    \item Описание устройств, набора инструкций и периферии~\cite{chip16-machspec}.
    \item Готовые образы памяти с приложениями, собранными для этой архитектуры~\cite{chip16-roms}.
\end{itemize}

\section{Структурная схема платформы}

Базовые узлы системы показаны на рис.~\ref{fig:chip16-platform}. Каждый обозначенный блок представляет собой один класс Simics, имя которого стоит после двоеточия.

\begin{figure}[htbp]
\centering
\begin{tikzpicture}[>=latex, node distance=0.5cm, font=\small]
\begin{scope}[minimum width=4cm]
    \node[draw] (cpu) {\textsc{cpu}: chip16};
    \node[draw, below = of cpu.south west, anchor=north west] (graph) {\textsc{graphics}: graph16};
    \node[draw, below = of graph.south west, anchor=north west] (joystick) {\textsc{joystick}: input16};
    \node[draw, below = of joystick.south west, anchor=north west] (sound) {\textsc{sound}: snd16};
    \node[draw, above = of cpu.north west, anchor = south west] (timer) {\textsc{timer}: videotimer};
\end{scope}

\begin{scope}[minimum width = 3.9cm, inner xsep = 0pt]
     \node[draw, rotate=90, right = 1cm of sound.south east, anchor=north west] (memory-space) {\textsc{cspace}: memory-space};
    \node[draw, rotate=90, right = 1cm of memory-space.south, anchor = north] (ram) {\textsc{ram}: ram};
    
    \node[draw, rotate=90, left = 1cm of cpu.north west, anchor=south east] (video-space) {\textsc{vspace}: memory-space};
    \node[draw, rotate=90, left = 1cm of video-space.south, anchor = south] (video-ram) {\textsc{video-ram}: ram};
\end{scope}

\draw[<->] (cpu.east) -- (cpu.east -| memory-space.north);
\draw[<-] (graph.east) -- (graph.east -| memory-space.north);
\draw[<-] (sound.east) -- (sound.east -| memory-space.north);
\draw[->] (joystick.east) -- (joystick.east -| memory-space.north);
\draw[<->] (graph.west) -- (graph.west -| video-space.south);

\draw[<->] (memory-space) -- (ram);
\draw[<->] (video-space) -- (video-ram);

\draw[->] (timer.west) -- ([xshift=-0.25cm]timer.west) |- (cpu);
\draw[->] (timer.west) -- ([xshift=-0.25cm]timer.west) |- (graph.175);
\draw[->] (timer.west) -- ([xshift=-0.25cm]timer.west) |- (joystick);

\end{tikzpicture}
\caption{Схема соединения блоков}\label{fig:chip16-platform}
\end{figure}

\section{Модификации спецификации для полноплатформенной модели}

Оригинальная документация не описывает некоторые важные для практического построения детали взаимодействия узлов. Поэтому для нужд задания вводятся уточнения по принципам работы ряда узлов.

\paragraph{Таймер.} Поскольку многие действия в платформе завязаны на синхросигнал от видеокарты, это моделируется с помощью отдельного устройства --- таймера \texttt{timer:videotimer}, генерирующего прерывания с периодом 16.67 мс по умолчанию. Он подключен к процессору, видеокарте и джойстикам, которые реагируют на поступление сигнала соответствующим образом.

\paragraph{VBLANK.} Инструкция \textsc{vblank} введена для синхронизации ЦПУ с видеопроцессором. В данной работе её семантика изменена. \textsc{vblank} вызывает остановку процессора до поступления следующего прерывания. Для обеспечения работы \textsc{vblank} используется прерывание от таймера. Процессор реагирует на прерывание пробуждением из режима остановки, если он в нём находится.

\paragraph{Инструкции DRW, PAL, SNG, CLS, BGC, SPR, FLIP, SNDx, SNP.} Данные инструкции предназначены для работы с периферией (видео и звуком). Для их реализации необходимо иметь однонаправленный канал для передачи сообщений. Для этих нужд используется  часть резервированного диапазона адресов I/O. Карта памяти выглядит следующим образом (от оригинальной она отличается введением дополнительных регистров в области MMIO).

\begin{tabular}{rrl}
Диапазон адресов         & Длина & Назначение \\
\texttt{0x0000 -- 0xfdef}& 65008 & ОЗУ        \\
\texttt{0xfdf0 -- 0xffef}& 512   & Стек       \\
\texttt{0xfff0 -- 0xfff1}& 2     & Джойстик 1 \\
\texttt{0xfff2 -- 0xfff3}& 2     & Джойстик 2 \\
\texttt{0xfff4 -- 0xfff5}& 2     & Звуковая карта \\
\texttt{0xfff6 -- 0xfff7}& 2     & Видеокарта \\
\texttt{0xfff8 -- 0xffff}& 8     & Зарезервировано \\
\end{tabular}

В работе используется уточнённый протокол работы с периферией, который учитывает ограниченность пропускной способности шин в реальных системах. Для передачи команд видеокарте и звуковой карте используются два канала связи по адресам 0xfff6 и 0xfff4 соответственно. Процессор кодирует необходимую для исполнения команду периферийного устройства согласно следующего протокола.

Все команды управления периферией состоят из одного или более слов. Первое слово определяет код команды и длину последовательности.

\bigskip

\bytefieldsetup{bitwidth=0.2cm, endianness = big}
\begin{bytefield}[]{16}
    \bitheader{16, 8, 7, 0} \\
    \bitbox{8}{Opcode} & \bitbox{8}{Length} \\
\end{bytefield}

Здесь Opcode --- код операции, Length --- полная длина последующей команды в словах. Последующие слова несут информацию, специфичную для конкретной команды.

Список команд для видеокарты почти полностью соотвествует аналогичным инструкциям процессора.

\begin{center}
\begin{tabular}{lll}
\textbf{Код команды}               & \textbf{Аргументы}      &  \textbf{Описание} \\
0, 3        & RXRX RYRY HHLL       &  Инструкция DRW\\
1, 24       & RRGG BBRR GGBB \dots &  Инструкция PAL \\
2, 1        & N000                 &  Инструкция BGC \\
3, 1        & HHLL                 &  Инструкция SPR \\
4, 1        & V000                 &  Инструкции FLIP \\
\end{tabular}
\end{center}

Отметим, что DRW требует прямого доступа к ОЗУ видеокартой для чтения данных спрайта.

\todo Установка флага C видеокартой в результате DRW.

Звуковая карта работает аналогичным образом.

\begin{center}
\begin{tabular}{lll}
\textbf{Код команды} & \textbf{Аргументы}  &  \textbf{Описание} \\
0, 2        & TONE HHLL  &  Инструкции SND0 --- SND3 \\
1, 2        &  RX,  HHLL &  Инструкция SNP \\
2, 2        &  ADVT SR00 &  Инструкция SNG \\
\end{tabular}
\end{center}

В первом приближении весь протокол общения между ЦПУ и периферийным устройством происходит атомарно. В улучшенных вариантах модели допускается разнести моменты передачи слов в виртуальном времени.

\section{Ход работы}

В данной секции разобраны общие вопросы организации разработки.
\subsection{Технология разработки}

\begin{itemize}
\item Хранение кода --- в Git \url{https://github.com/yulyugin/ilab-simics}. Лицензия кода --- закрытая, согласно договора предоставления Intel Academic SLA 1.0 (см.~пункт 6.2 соглашения).

\item Документация --- в вики \url{https://github.com/yulyugin/ilab-simics/wiki}.

\item Распределение задач --- по одному модулю Simics на одного--двух выполняющих.
\item Промежуточная проверка качества --- юнит тесты для отдельных устройств.
\item Финальный продукт работы --- набор моделей и связывающий их скрипт (построенный на основе стандартной цели cosim)
\end{itemize}

\subsection{ЦПУ}

Основа для модели --- модифицированный \texttt{sample-risc}, модифицированный для нужд учебного проекта:
\begin{itemize}
    \item убрана многоядерность;
    \item декодер упрощён до одной инструкции;
	\item код регистрации класса обновлён до современной схемы.
	\item Endianness изменена с BE на LE.
\end{itemize}


\subsection{Видеоконтроллер}

Основа для модели --- \texttt{sample-device-c}. Отрисовка изображения производится через SDL. Пример работы с экраном и клавиатурой из SDL: \url{http://www.aaroncox.net/tutorials/2dtutorials/sdlkeyboard.html}. Для 2.0: \url{http://www.sdltutorials.com/sdl-tutorial-basics}, \url{https://wiki.libsdl.org/MigrationGuide}.

Пример на русском языке: \url{http://habrahabr.ru/post/134936/}

\subsection{Джойстик}

Основа для модели --- \texttt{sample-device-c}. Ввод с хозяйской клавиатуры производится через SDL.

\subsection{Таймер}

Основа для модели --- \texttt{sample-timer-device}. Код пишется на DML.

\section{Минимум и максимум цели проекта}

В зависимости от полноты выполнения студентами подзадач проекта выделяются следующие вехи, обозначающие достижение следующей ступени к симуляции, по сравнению с референсной моделью \textsc{mash16}.

\begin{enumerate}
    \item Модель способна исполнять образ памяти, написанный участниками проекта.
    \item Модель способна исполнять образ памяти из директории Demo (графическое приложение без звука и ввода).
    \item Модель способна исполнять образ памяти из директории Demo (графическое приложение со звуком и без ввода).
    \item Модель способна исполнять образ памяти из директории Games (графическое приложение со звуком и вводом с джойстика).
\end{enumerate}

\section{Порядок занятий и заданий}

\begin{tabular}{p{0.4\textwidth}p{0.4\textwidth}}
\textbf{Занятие} & \textbf{Задание} \\\hline
Системы контроля версий Git & Установить Linux, скачать репозиторий проекта, изменить файл, зафиксировать изменения в репозитории \\
Сборка проекта: модули, модели, workspace & Собрать заглушки модулей, создать недостающие устройства (распределение устройств по владельцам) \\
Структура кода моделей Simics: атрибуты, интерфейсы, функция init_local() & Начать заполнять устройства архитектурным состоянием \\
Архитектура CHIP16 & Продолжать работу над устройствами \\
Моделирование ЦПУ через интерпретацию; моделирование графики & Реализовать первые инструкции в процессоре; подключить библиотеку SDL к сборке проекта\\
Моделирование ввода с клавиатуры. Интерактивность симуляции. MMIO. Прерывания & Продолжать писать модели устройств \\
Тестирование устройств. Среда Simics для конфигурации соединения устройств симуляции. & Запустить скрипт targets/chip16; написать свои скрипты для отдельных устройств \\

\end{tabular}

\section{Контрольные вопросы}

\begin{enumerate*}
\item Какие устройства в CHIP16 моделируются как исполняющие, а какие --- как неисполняющие? Почему? Есть ли устройства, которые моделируются как-то по-другому? Почему они не принадлежат ни к одному из двух классов?
\item Почему в данной главе описываются расширения оригинальной спецификации в виде протоколов связи между устройствами, а также дополнительных устройств типа таймера, если в исходной спецификации их нет?
\item Какие проблемы могут возникнуть при симуляции звука, генерируемого звуковой картой, при проигрывании его через физические динамики хозяина?
\end{enumerate*}


\iftoggle{webpaper}{
    \printbibliography[title={Список литературы к занятию}]
}{}