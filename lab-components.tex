\chapter{Концепции симуляции}\label{chap:lab02}

\section{Цель занятия}

В данной лабораторной работе продолжается изучение принципов работы симулятора Simics. В ней будут определены основные понятия, используемые при работе с симуляцией и при написании моделей устройств.

Запустите симулятор со сценарием моделируемой системы \texttt{viper-busybox}:

\begin{lstlisting}
$ ./simics -e '$cpu_class=core-i7-single' targets/x86-x58-ich10/viper-busybox.simics
\end{lstlisting}

\subsection{Единицы симуляции} 

Аналогично тому, что физические системы собираются из устройств, программные платформы состоят из моделей отдельных узлов. При этом, как и в реальности, они образуют иерархическую структуру. Выбираемый уровень детализации зависит от целей симуляции и от возможностей симулятора. 

Рассматриваемая в качестве примера в данной работе модель системы Viper соответствует физической системе, основанной на материнской плате формата Intel X58, набора системной логики ICH10 и центрального процессора Intel Core i7, кодовое имя микроархитектуры Nehalem. Вернеуровневая (т.н. компонентная) структура модели приведена на рис.~\ref{fig:x58-components}.

\begin{figure}[htb]
    \centering
    \includegraphics[width=0.6\textwidth]{x58-components}
    \caption{Окно для просмотра объектов и их атбрибутов}
    \label{fig:x58-components}
\end{figure}


\section{Устройства и классы Simics}

\section{Компоненты}

\subsection{Иерархия устройств}

Корневой элемент созданной модели компьютера имеет имя, хранящееся в переменной \texttt{\$system}. В нашем случае это \texttt{viper} --- модель шасси, на котором <<крепятся>> все остальные устройства. Этот факт выражается в том, что иерархические имена подкомпонент образованы присоединением к имени надкомпоненты своего имени через символ точки. Так, материнская плата данной системы имеет имя \texttt{viper.mb}, процессор на ней --- \texttt{viper.mb.cpu0}, а первое ядро в этом процессоре --- \texttt{viper.mb.cpu0.core[0][0]}.

Для просмотра списка всех устройств используйте команду \texttt{list-objects -recursive}. Альтернативно можно использовать окно \textbf{Object Browser} (рис.~\ref{fig:object-browser}).

\begin{figure}[htb]
    \centering
    \includegraphics[width=0.8\textwidth]{win-object-browser}
    \caption{Окно для просмотра объектов и их атбрибутов}
    \label{fig:object-browser}
\end{figure}

\section{Команды}

Каждый класс моделей может предоставлять несколько команд, которые позволяют инспектировать или изменять состояние объектов данного класса. Такие команды приписываются к иерархическому имени модели.

Самые часто реализуемые внутри классов команды --- это \texttt{status} и \texttt{info}.

Так же все устройства модели памяти имеют команды \texttt{get} и \texttt{set}, которые позволяют читать и записывать данные в симулируемую память. Например:

\begin{lstlisting}
simics> viper.mb.cpu0.mem[0][0].get address = 0xffff0000

simics> viper.mb.cpu0.mem[0][0].set address = 0xffff0000 value = 0xaabbccdd
\end{lstlisting}


\subsection{Глобальные команды}

Кроме команд, специфичных для устройств, существуют так называемые глобальные команды, эффект которых состоит или в доступе к состоянию всей симуляции в целом, или же к текущему <<устройству>> некоторого класса, что позволяет сэкономить время на наборе иерархических имён. Например, команда \texttt{ptime} выводит значения симулируемого времени для текущего процессора, тогда как \texttt{ptime -all} позволяет увидеть аналогичную информацию о всех процессорах в системе.

\begin{lstlisting}
simics> ptime
processor                 steps   cycles   time[s]
viper.mb.cpu0.core[0][0]      0        0         0
\end{lstlisting}



\section{Диагностические сообщения}

Одно из назначений симуляторов --- помогать в разработке аппаратуры и программ для неё. При этом разработчикам необходимо понимать, что происходит в системе в определённые моменты времени. Для этого всем моделям позволено создавать диагностические сообщения, которые могут выводится на консоль управления Simics, а также в файл. Поскольку излишне частые и подробные сообщения могут засорить журнал, Simics предоставляет несколько механизмов для их фильтрации.



\section{Атрибуты}

Атрибуты являются аналогом полей классов в парадигме ООП. В симуляции основная их задача состоит в хранении архитектурного состояния моделей. Обратиться к ним можно по их имени, указываемому после имени объекта, с помощью оператора <<\texttt{->}>>:

Например, для просмотра регистров центрального процессора можно использовать соответствующие атрибуты:
\begin{lstlisting}
simics> viper.mb.cpu0.core[0][0]->rax
0
simics> viper.mb.cpu0.core[0][0]->rip
65520
simics> viper.mb.cpu0.core[0][0]->rdx
67233
simics> viper.mb.cpu0.core[0][0]->xmm
[[0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0]]
\end{lstlisting}

Для изменения значения, хранимого в атрибуте, используется оператор присваивания <<\texttt{=}>>:
\begin{lstlisting}
simics> viper.mb.cpu0.core[0][0]->rax = 123
\end{lstlisting}

\subsection{Типы атрибутов}

По аналогии с переменными в языках программирования атрибуты имеют типы. При присвоении атрибуту нового значения предварительно производится проверка, что тип выражения с правой стороны соответствует его заявленному типу.

Типы атрибутов специфицируются с помощью строки, символы которой определяют допустимые варианты входных значений.

\begin{enumerate*}
\item Скалярные. Имеют типы \texttt{i}, \texttt{s}, \texttt{b}.
\item Объекты. Их тип --- \texttt{o}.
\item Списки. Они могут быть как однородными \texttt{[iiii]}, так и содержать элементы разных типов \texttt{[oios]}. Кроме того, их длина может быть переменной: \texttt{[i*]}.
\item Пустой тип \texttt{n}.
\item Допустимо иметь атрибут, тип которого выбирается из нескольких ранее описанных: \texttt{i|s|o}.

\end{enumerate*}

Кроме того, некоторые атрибуты при регистрации могут быть помечены как псевдоатрибуты или атрибуты только для чтения. Почти всегда они не соответствуют архитектурному состоянию, а используются для удобства представления информации об устройстве или же могут быть выведены из содержимого других атрибутов.

\section{Задания}

 В этой работе мы будем создавать небольшую симуляцию, состоящую из простой модели процессора класса \texttt{sample-risc} и модели оперативной памяти. Для этого необходимо будет создать и настроить индивидуальные объекты. Исходный скрипт находится в файле \texttt{script.py} (см. приложение~\ref{chap:app-broken-script}). Однако он содержит несколько ошибок, которые не позволяют это сделать сразу. Задание состоит в том, чтобы разобрать сообщения симулятора, внести модификации в исходный скрипт и запустить его.

Следующие замечания должны помочь в решении поставленной задачи.

\begin{itemize*}
    \item Данный скрипт написан на языке Python и поэтому требует специального флага при указании его имени в командной строке.
    \item Для выяснения списка опций используйте команду \texttt{simics -h}.
    \item Переменные в Simics объявляются с помощь оператора <<\texttt{=}>>. Имена переменных начинаются со знака доллар, например \texttt{\$system}.
    \item Перед выполнением второй фазы инициализации объектов все обязательные атрибуты предобъектов должны быть настроены.
    \item Обращайте внимание на вывод сообщения об ошибках --- часто они содержат имя файла и номер строки.
    \item Комментарии начинаются со знака <<диез>> \texttt{\#}.
\end{itemize*}

\section{Контрольные вопросы}

\begin{enumerate*}
\item 
\item 
\item 
\end{enumerate*}


\iftoggle{webpaper}{
    \printbibliography[title={Список литературы к занятию}]
}{}
