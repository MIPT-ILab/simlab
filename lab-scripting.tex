\chapter{Язык сценариев Simics}\label{chap:scripting}

\section{Цель занятия}

В данной лабораторной работе продолжается изучение принципов работы симулятора Simics. В ней будут даны основы языка сценариев конфигурации Simics, а также использование языка Python. 
Подробная информация может быть также найдена в~\cite{hindsight}.

\section[Файлы, интерактивный ввод и опции]{Файлы сценариев, интерактивный ввод и опции командной строки}

Во время своей работы окружение Simics, кроме объектов моделей устройств, предоставляет динамическую среду программирования с переменными, ветвлениями, циклами и другими возможностями. Пользователям, знакомым с Unix Shell, Windows CMD.EXE и другими REPL\footnote{От \abbr read-eval-print loop.}-системами, она окажется достаточно привычной.

Все команды, понимаемые Simics, можно вводить тремя способами.

\begin{enumerate*}
\item Через \textit{файл сценария}. Традиционно такие файлы получают расширение \texttt{.simics}. Имя файла передаётся как опция командной строки Simics, после чего все его строки интерпретируются как команды и исполняются в неинтерактивном режиме, т.е. без возможности пользователя повлиять на ход исполнения. Если указано несколько имён файлов, то все они будут исполнены последовательно.

Файлы сценариев чаще всего используются для конструирования моделируемой системы из отдельных компонент. При этом в изначально пустой симуляции возникает готовая к запуску виртуальная система с заданными устройствами и фиксированными настройками, с которой пользователь затем проводит эксперименты.

Кроме того, имеется возможность создавать полностью неинтерактивные сценарии, которые протекают от начала до конца без участия человека. Для этого последней строкой файла должна быть команда \texttt{quit}, завершающая работу симулятора.

Например, если в корне текущего workspace есть файл \texttt{1.simics} со следующим содержимым:
\begin{lstlisting}
# 1.simics - a short script
# This is comment
if not defined a {$a = 2}
echo "Variable a is " + $a
echo "About to exit"
quit
\end{lstlisting}

То его исполнение приведёт к следующему выводу:
\begin{lstlisting}
$ ./simics 1.simics
Wind River Simics 4.8 (build 4561 linux64) Copyright 2010-2014 Intel Corporation

Use of this software is subject to appropriate license.
Type 'copyright' for details on copyright and 'help' for on-line documentation.

Variable a is 2
About to exit
$ 
\end{lstlisting}

\item  После исполнения последней строки из последнего файла сценария симулятор переходит в \textit{интерактивный режим}, и пользователь может вводит новые команды через строку приглашения (\abbr command prompt). Вывод каждой команды, если он есть, будет распечатан сразу после её завершения и перед возвращением управления пользователю.

\item Наконец, команды можно указывать прямо \textit{в опциях командной строки} Simics, с ключом \texttt{-e}. При этом, если в команде есть специальные символы, интерпретируемые самой командной оболочкой операционной системы, то их приходится <<прятать>> с помощью кавычек. Для Unix Shell среди них содержатся символы пробела, доллара, одинарные и двойные кавычки, обратные слеши.

Тот же самый файл сценария \texttt{1.simics} выдаст другое значение для переменной \texttt{a}, если её значение переопределить в командной строке:

\begin{lstlisting}
$ ./simics -e '$a="_changed_"' 1.simics
Wind River Simics 4.8 (build 4561 linux64) Copyright 2010-2014 Intel Corporation

Use of this software is subject to appropriate license.
Type 'copyright' for details on copyright and 'help' for on-line documentation.

Variable a is _changed_
About to exit
$
\end{lstlisting}

Заметим, что, в отличие от многих утилит Linux, порядок аргументов командной строки Simics важен --- он определяет порядок их исполнения. Все принимаемые флаги можно увидеть, исполнив \texttt{simics -help}.
\end{enumerate*}

\section{Переменные окружения}

В процессе работы симуляции пользовательские данные можно хранить в переменных. В Simics переменные имеют имена, начинающиеся со знака доллара. Они могут хранить числа, строки, булевы значения и списки. Как и во многих других скриптовых языках, тип переменных определяется динамически. 

Пример операций с переменными:
\begin{lstlisting}
simics> $a
No CLI variable "a"
simics> $a = 2
simics> $a
2
simics> $a = "text value"
simics> $a
"text value"
simics> $a =(3+4)/5
simics> $a
1
simics> $a =(3+4)/5.0
simics> $a
1.4
simics> $a = [1,2,3]
simics> $a
[1, 2, 3]
simics> $a = TRUE
simics> $a
TRUE
simics> defined a
TRUE
simics> defined b
FALSE
\end{lstlisting}

Очень часто переменные используются как элементы конфигурации гостевой платформы при её создании. Фиксированного соглашения на их именование нет; однако, традиционно \texttt{\$cpu_class} содержит имя процесссора, \texttt{\$system} --- имя создаваемого компонента верхнего уровня (т.е. материнской платы), \texttt{\$disk} --- путь к образу диска и т.д.

Для того, чтобы увидеть все определённые переменные, используется команда \texttt{list-variables}. Например, для скрипта \texttt{viper-busybox.simics} определены десятки переменных, используемых для первоначальной конфигурации:

\begin{lstlisting}
simics> list-variables
$apic_freq_mhz           = 133
$bios                    = "seabios-simics-x58-ich10-sata-1.6.3-20131111.bin"
$break_on_reboot         = TRUE
$cdrom                   = "viper.cdrom"
$connect_real_network    = TRUE
$connect_usb_tablet      = FALSE
$console                 = "viper.console"
$cpi                     = 1
$cpu                     = ["viper.mb.cpu0"]
$cpu_class               = "core-i7"
$create_network          = TRUE
$create_processor        = "create-processor-core-i7"
$dhcp_pool_ip            = "10.10.0.100"
$dhcp_pool_size          = 100
$dimm                    = "viper.mb.memory"
$disk                    = "viper.disk"
$disk_size               = 20496236544
$efi                     = FALSE
$enter_in_boot_menu      = TRUE
$eth_cnt                 = "eth_slot"
$eth_comp                = "viper.mb.sb"
$eth_link                = "ethernet_switch0"
$freq_mhz                = 2000
...
\end{lstlisting}

\section{Управляющие конструкции}

В языке сценариев Simics используются классические команды для управлением исполнения, такие как \texttt{if (cond) then \{op1\} else \{op2\}}, \texttt{while cond \{op\}} и \texttt{foreach \$var in \$list \{op\} }. Также доступна конструкция для ловли исключений \texttt{trу \{op1\} except \{op2\}}.

\section{Python}

Кроме использования собственного языка сценариев Simics позволяет использовать отдельные команды и даже целые файлы, написанные на Python. Для отдельных команд необходимо использовать знак <<эт>>  в начале строки для того, чтобы интерпретатор понял, что синтаксис последующего текста следует разбирать как Python-строку:
\begin{lstlisting}
simics> @print "Hello"
Hello
\end{lstlisting}

Для запуска целого файла, написанного на Python, следует использовать команду \texttt{run-python-file <file>} или указать его с флагом \texttt{-p} командной строки Simics:
\begin{lstlisting}
$ ./simics -p 2.py
\end{lstlisting}

\section{Ход работы}

\todo 

% \section{}

\section{Последовательность конструирования модели системы}

При создании симуляции она и все участвующие в ней объекты проходят две фазы, чётко отделённые друг от друга во времени, тогда как внутри каждой из них порядок инициализации компонент неопределён.

\begin{enumerate*}

\item \textit{Объявление} устройств и соединение их с помощью инициализации их атрибутов. На этом этапе ещё не произодится проверок на соответствие типов, определённость значений всех обязательных атрибутов. Устройства представлены так называемыми предобъектами (\abbr preobj).

\item \textit{Инстанциирование} устройств с помощью команды \texttt{instantiate-components} или с помощью вызова \texttt{SIM_add_configuration()}, например, из Python. На этом этапе производятся все проверки на корректность атрибутов, наличие необходимых интерфейсов и т.п. Если не найдено ошибок, то предобъекты преобразуются в полноценные объекты Simics, которые могут участввать в симуляции. Если обнаружены ошибки, то уже созданные объекты удаляются, а последующие не создаются.

\item \textit{Пост-инициализация}. Некоторые устройства требуют дополнительного шага. Желательно, чтобы объём действий, выполняемых в этой фазе, был минимален.

\end{enumerate*}

При необходимости добавить новые объекты в процессе симуляции описанные фазы могут быть повторены.

\section{Задания}

\begin{enumerate*}
\item Из документации Hindsight~\cite{hindsight} выясните, каким образов на Python записать следующие конструкции: 1) присваивание переменной Simics \texttt{\$var} значения \texttt{"test"}; 2) чтение атрибута \texttt{classname} устройства с именем \texttt{dev0}; 3) Вызов метода \texttt{fun()} интерфейса \texttt{sample_interface} устройства \texttt{board.nb.cb[0][0]}.
\item Найдите способ программно узнать, какую версию Python использует Simics.
\end{enumerate*}


\section{Контрольные вопросы}

\begin{enumerate*}
\item Перечислите три способа ввода команд в Simics.
\item Для каких нужд могут понадобится полностью неинтерактивные сценарии симуляции? Приведите несколько примеров.
\item Найдите, откуда появляются значения всех переменных из сценария \texttt{viper-busybox} при условии, что их не задали в командной строке или вручную.
\item Придумайте способ прочитать значение некоторой переменной из модели устройства. Почему не существует прямого API для выполнения подобной операции?
\end{enumerate*}

\iftoggle{webpaper}{
    \printbibliography[title={Список литературы к занятию}]
}{}




